// RobotBuilder Version: 2.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// C++ from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.

#include "Subsystems/Vision.h"
// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=INCLUDES
// END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=INCLUDES

// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTANTS
// END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTANTS

Vision::Vision() : frc::Subsystem("Vision") {
    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
    auto table = nt::NetworkTableInstance::GetDefault().GetTable("limelight");
    tx = table->GetEntry("tx");
	ty = table->GetEntry("ty");
    tv = table->GetEntry("tv");
    tl = table->GetEntry("tl");
    getPipe = table->GetEntry("getpipe");
	ledMode = table->GetEntry("ledMode");
	camMode = table->GetEntry("camMode");
	setPipe = table->GetEntry("pipeline");
	snapshot = table->GetEntry("snapshot");
    distance = table->GetEntry("distance");
    distance.SetDouble(0);
    automove = table->GetEntry("automove");
    automove.SetBoolean(false);

    mAA = table->GetEntry("Vision Min Align Adjust");
    kP_O = table->GetEntry("Vision kP Omega");
    kP_D = table->GetEntry("Vision kP Distance");
    mAA.SetDouble(min_AlignAdjust);
    kP_O.SetDouble(kP_Omega);
    kP_D.SetDouble(kP_Distance);
}

void Vision::InitDefaultCommand() {
    // Set the default command for a subsystem here.
    // SetDefaultCommand(new MySpecialCommand());
    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND
}

void Vision::Periodic() {
    // Put code here to be run every loop

}

// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CMDPIDGETTERS
// END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CMDPIDGETTERS


// Put methods for controlling this subsystem
// here. Call these from Commands.

/**
 * @brief Checks if a target is locked. 
 * 
 * @return true when target locked
 * @return false when target not found
 */
bool Vision::TargetIsLocked() {
    return (tv.GetDouble(0) == 1);
}

/**
 * @brief Returns tx from limelight network tables
 * Should only be called if a target is locked
 * 
 * @return x-angle from target in degrees
 */
double Vision::GetXAngleToTarget() {
   return tx.GetDouble(0);
}

/**
 * @brief Calculates distance from the front bumper of robot to the powerport in ft
 * Should only be called when a powerport target is locked
 *
 * @return distance from powerport 
 */
double Vision::GetDistanceToPowerport() {
    double angleToTarget = (cameraAngle + ty.GetDouble(0)) * Deg2Rad;
    double camToPowerPortDistance  = (powerportVisionTargetHeight - cameraHeight) / tan(angleToTarget);
    return camToPowerPortDistance - cameraDistanceFromFrontBumper;
}

/**
 * @brief gets combined latency of the pipeline and image capture in ms
 * 
 * @return combined latency of the pipeline and image capture in milliseconds
 */
double Vision::GetLatency() {
    return tl.GetDouble(0) + 11;
}

/**
 * @brief Sets the LED Mode of the camera
 * 
 * @param ledModeToSet LEDMode enum value
 *
 */
void Vision::SetLEDMode(LEDMode ledModeToSet) {
    int ledModeValue = ledModeToSet;
    ledMode.SetDouble((double)ledModeValue);
}

/**
 * @brief Switches between vision processing and drive mode
 * 
 * @param visionProcessingEnabled true enables vision processing, false stops vision processing and increases exposure
 */
void Vision::SetCamMode(bool visionProcessingEnabled) {
    if (visionProcessingEnabled)
    {
        camMode.SetDouble(0);
    }
    else
    {
        camMode.SetDouble(1);
    }
}

/**
 * @brief Sets the current vision processing pipeline
 * 
 * @param pipeline the pipeline to use
 */
void Vision::SetPipeline(Pipeline pipeline) {
    int pipelineIndex = pipeline;
    setPipe.SetDouble((double)pipelineIndex);
}

/**
 * @brief Steers the robot to minimize the distance and angle error
 * 
 * Runs 2 P controllers. First runs a p controller on the angleError, then once the robot is close to
 * aligned this starts running a p controller for distance error as well. 
 * 
 * @param angleError the angle error in degrees, desired angle - current angle
 * @param distanceError the distanc error in feet, desired position - current position
 */
void Vision::VisionSteerController(double angleError, double distanceError, std::shared_ptr<rev::CANPIDController> pidControllerL, std::shared_ptr<rev::CANPIDController> pidControllerR) {
   
   /*
	kP_Omega  = frc::Preferences::GetInstance()->GetDouble("Vision kP Omega", kP_Omega);
    min_AlignAdjust = frc::Preferences::GetInstance()->GetDouble("Vision Min Align Adjust", min_AlignAdjust);
    kP_Distance = frc::Preferences::GetInstance()->GetDouble("Vision kP Distance", kP_Distance);
 */
    kP_Omega = kP_O.GetDouble(kP_Omega);
    min_AlignAdjust = mAA.GetDouble(min_AlignAdjust);
    kP_Distance = kP_D.GetDouble(kP_Distance);
    double steeringAdjust = 0.0;
    double distanceAdjust = 0.0;

    // if robot not aligned with target run alignment p Controller
    if (angleError > 0)
    {
        steeringAdjust = kP_Omega * angleError + min_AlignAdjust;
    }   
    else if (angleError < 0)
    {
        steeringAdjust = kP_Omega * angleError - min_AlignAdjust;
    }

    // if robot close to aligned run distance p controller
    if (abs(angleError) < 5)
    {
        distanceAdjust = kP_Distance * distanceError;
    }  

    pidControllerL->SetReference(steeringAdjust + distanceAdjust, rev::ControlType::kVelocity);  
    pidControllerR->SetReference(steeringAdjust - distanceAdjust, rev::ControlType::kVelocity);
    

}


