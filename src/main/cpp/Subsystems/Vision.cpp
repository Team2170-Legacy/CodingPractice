// RobotBuilder Version: 2.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// C++ from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.


#include "Subsystems/Vision.h"
// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=INCLUDES
// END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=INCLUDES

// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTANTS
// END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTANTS

Vision::Vision() : frc::Subsystem("Vision") {
    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
    	auto table = nt::NetworkTableInstance::GetDefault().GetTable("limelight");
    tx = table->GetEntry("tx");
	ty = table->GetEntry("ty");
    tv = table->GetEntry("tv");
    tl = table->GetEntry("tl");
    getPipe = table->GetEntry("getpipe");
	ledMode = table->GetEntry("ledMode");
	camMode = table->GetEntry("camMode");
	setPipe = table->GetEntry("pipeline");
	snapshot = table->GetEntry("snapshot");
    automove = table->GetEntry("automove");
    automove.SetBoolean(false);
}

void Vision::InitDefaultCommand() {
    // Set the default command for a subsystem here.
    // SetDefaultCommand(new MySpecialCommand());
    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND
}

void Vision::Periodic() {
    // Put code here to be run every loop

}

// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CMDPIDGETTERS
// END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CMDPIDGETTERS


// Put methods for controlling this subsystem
// here. Call these from Commands.

/**
 * @brief Checks if a target is locked. 
 * 
 * @return true when target locked
 * @return false when target not found
 */
bool Vision::targetLocked() {
    return (tv.GetDouble(0) == 1);
}

/**
 * @brief Returns tx from limelight network tables
 * This should only be called if a target is locked
 * 
 * @return x-angle from powerport
 */
double Vision::getXAngleToPowerport() {
   return tx.GetDouble(0);
}

/**
 * @brief Calculates distance from the front bumper of robot to the powerport in ft
 * 
 * @return distance from powerport if target locked, -1 otherwise
 */
double Vision::getDistanceToPowerport() {
    if (targetLocked())
    {
        double angleToTarget = (cameraAngle + ty.GetDouble(0)) * Deg2Rad;
        double camToPowerPortDistance  = (powerportVisionTargetHeight - cameraHeight) / tan(angleToTarget);
        return camToPowerPortDistance - cameraDistanceFromFrontBumper;
    }
    return -1;
}

/**
 * @brief gets combined latency of the pipeline and image capture in ms
 * 
 * @return combined latency of the pipeline and image capture in milliseconds
 */
double Vision::getLatency() {
    return tl.GetDouble(0) + 11;
}

/**
 * @brief Sets the LED Mode of the camera
 * 
 * @param ledModeToSet LEDMode enum value
 *
 */
void Vision::setLEDMode(LEDMode ledModeToSet) {
     int ledModeValue = ledModeToSet;
    ledMode.SetDouble((double)ledModeValue);
}

/**
 * @brief Switches between vision processing and drive mode
 * 
 * @param visionProcessingEnabled true enables vision processing, false stops vision processing and increases exposure
 */
void Vision::setCamMode(bool visionProcessingEnabled) {
    camMode.SetBoolean(visionProcessingEnabled);
}

/**
 * @brief Sets the current vision processing pipeline
 * 
 * @param pipeline the pipeline to use
 */
void Vision::setPipeline(Pipeline pipeline) {
    int pipelineIndex = pipeline;
    setPipe.SetDouble((double)pipelineIndex);
}

void Vision::VisionSteerController(double angleError, double distance) {
   
	kP_Omega        = frc::Preferences::GetInstance()->GetDouble("Vision kP Omega", kP_Omega);
   min_command       = frc::Preferences::GetInstance()->GetDouble("Vision Min Command", min_command);

    double heading_error = angleError;
    double steering_adjust = 0.0;
    if (angleError > 1.0)
    {
        steering_adjust = kP_Omega * heading_error - min_command;
    }
    else if (angleError < 1.0)
    {
        steering_adjust = kP_Omega * heading_error + min_command;
    }

    // Send vL and vR to CAN Spark Maxes
    Robot::driveTrain->pidControllerL->SetReference(steering_adjust, rev::ControlType::kVelocity);  
    Robot::driveTrain->pidControllerR->SetReference(-steering_adjust, rev::ControlType::kVelocity);  
}